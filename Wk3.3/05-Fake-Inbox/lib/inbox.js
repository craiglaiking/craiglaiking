const hasNewMessage = () => {
  // math.randon returns a random decimal between 0 and 1.
  // The < will compare the math.random result and return a boolean result.
  // 0.2 is the comparative figure provinf the 20% probabiloty the statement will be true.
  return Math.random() < 0.2;
  // TODO: return true with a probability of 20%.
};


  /* Solution from first part of exercise: Using random dummy data
  const newMessage = () => {
    //Create random list of senders
    let senderList = ["Andrew", "Ben", "Craig"]
    // Determine the maximum index of the array in senderList
    let randomSenderIndex = senderList.length
    // Step 1: Math.random() * randomSenderIndex will always be less than the index of the array
    // eg. 0.9 (largest figure generated by Math.random) *  3 (length of array) = 2.7.
    // Step 2: Math.floor returms largest INTEGER less than a defined number, which in this case is 2.7
    // Therefore, Math.floor(2.7) = 2 --> which is the final INDEX figure of the senderList array
    let randomSender = senderList[Math.floor(Math.random() * randomSenderIndex)];

    let subjectList = ["Welcome", "News for you", "Congratulations"]
    let randomSubjectIndex = subjectList.length
    let randomSubject = subjectList[Math.floor(Math.random() * randomSubjectIndex)];

    // Returns an object with two keys
    let newObject = {sender: randomSender, subject: randomSubject};

    return newObject;

  // TODO: return a random message as an object with two keys, subject and sender
}
*/

// Pulling from API
const newMessage = (callback) => {
   fetch("https://raw.githubusercontent.com/johncalvinroberts/03-Wagon-Race/master/stories.json")
       .then(response => response.json())
       .then((data) => {
         console.log(data);
         // Add your code to get `name` and `text` values from data and put into the `sender` and `subject` message object.
         callback(data)
    //return message; // This is wrong!!
  });
       }
const refresh =  () => {
if(hasNewMessage){
      newMessage(appendMessageToDom)  // the input parameter of appendMessageToDom should be all the data fetched from API
  }
};
// };
// const myMsgs = newMessage() // myMsgs will be undefined.

// Need to re-code so pull in dat from APi database
const appendMessageToDom = (message) => {
  // Calling in the function newMessage so I can access variables declared in the newMessaeg function
  let newObjectProperties = newMessage()
  // Select the div which will become the reference point when inserting new content
  let theDiv = document.querySelector('#inbox div')
  // content defined as the <div> content
  let content = `<div class="row message unread">
      <div class="col-3">${newObjectProperties.sender}</div>
      <div class="col-9">${newObjectProperties.subject}</div>
    </div>`;
  //InsertAdjacent HTML is the modern way to insert HTML text into HTML code
  //insertAdjacentHTML("position", /content to be included/)
  theDiv.insertAdjacentHTML("beforebegin", content)

  // TODO: append the given message to the DOM (as a new row of `#inbox`)
};

/* commented out in response to loading in API
const refresh = () => {
  // Integrate hasNewMessage function so new emails come through only if hasNewMessage is true (i.e 20% of the time)
  if (hasNewMessage() === true) {
  appendMessageToDom()
  }

  // Select the H1 which includes the number of unread emails
  let theH1Counter = document.querySelector('#count')
  // Use querySelector to identify divs that relate to unread emails
  // NB. querySelectorALL must be used as we're analysing ALL divs.
  let unreadEmails = document.querySelectorAll('#inbox div.unread')
  // Count the number of divs that relate to unread emails
  let emailCounter = unreadEmails.length
  // debugging example
  console.log(emailCounter)
  // use innerHTML to change the number realting to unread emails in the H1 heading
  theH1Counter.innerHTML = `(${emailCounter})`


  // Suggest not to use "location.reload" as it refreshes the entire page every single time instead of fetching new infor from the server


  // TODO: Implement the global refresh logic. If there is a new message,
  //       append it to the DOM. Update the unread counter in title as well.
};
*/














// Do not remove these lines:
document.addEventListener("DOMContentLoaded", () => {
  setInterval(refresh, 1000); // Every 1 second, the `refresh` function is called.
});

